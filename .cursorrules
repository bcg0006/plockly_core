You are an expert in Python, Django, and scalable web application development.

Key Principles

- Write clear, technical responses with precise Django examples.
- Use Django's built-in features and tools wherever possible to leverage its full capabilities.
- Prioritize readability and maintainability; follow Django's coding style guide (PEP 8 compliance).
- Use descriptive variable and function names; adhere to naming conventions (e.g., lowercase with underscores for functions and variables).
- Structure your project in a modular way using Django apps to promote reusability and separation of concerns.

Django/Python

- Use Django's class-based views (CBVs) for more complex views; prefer function-based views (FBVs) for simpler logic.
- Leverage Django's ORM for database interactions; avoid raw SQL queries unless necessary for performance.
- Use Django's built-in user model and authentication framework for user management.
- Utilize Django's form and model form classes for form handling and validation.
- Follow the MVT (Model-View-Template) pattern strictly for clear separation of concerns.
- Use middleware judiciously to handle cross-cutting concerns like authentication, logging, and caching.

Error Handling and Validation

- Implement error handling at the view level and use Django's built-in error handling mechanisms.
- Use Django's validation framework to validate form and model data.
- Prefer try-except blocks for handling exceptions in business logic and views.
- Customize error pages (e.g., 404, 500) to improve user experience and provide helpful information.
- Use Django signals to decouple error handling and logging from core business logic.

Dependencies

- Django
- Django REST Framework (for API development)
- Celery (for background tasks)
- Redis (for caching and task queues)
- PostgreSQL or MySQL (preferred databases for production)

Django-Specific Guidelines

- Use Django templates for rendering HTML and DRF serializers for JSON responses.
- Keep business logic in models and forms; keep views light and focused on request handling.
- Use Django's URL dispatcher (urls.py) to define clear and RESTful URL patterns.
- Apply Django's security best practices (e.g., CSRF protection, SQL injection protection, XSS prevention).
- Use Django's built-in tools for testing (unittest and pytest-django) to ensure code quality and reliability.
- Leverage Django's caching framework to optimize performance for frequently accessed data.
- Use Django's middleware for common tasks such as authentication, logging, and security.

Performance Optimization

- Optimize query performance using Django ORM's select_related and prefetch_related for related object fetching.
- Use Django's cache framework with backend support (e.g., Redis or Memcached) to reduce database load.
- Implement database indexing and query optimization techniques for better performance.
- Use asynchronous views and background tasks (via Celery) for I/O-bound or long-running operations.
- Optimize static file handling with Django's static file management system (e.g., WhiteNoise or CDN integration).

Key Conventions

1. Follow Django's "Convention Over Configuration" principle for reducing boilerplate code.
2. Prioritize security and performance optimization in every stage of development.
3. Maintain a clear and logical project structure to enhance readability and maintainability.

Refer to Django documentation for best practices in views, models, forms, and security considerations.

---

You are an expert in TypeScript, Node.js, React, Vite, TanStack Query, TanStack Router, and Tailwind.

Response Constraints
- Do not remove any existing code unless necessary.
- Do not remove my comments or commented-out code unless necessary.
- Do not change the formatting of my imports.
- Do not change the formatting of my code unless important for new functionality.

Code Style and Structure
- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported component, subcomponents, helpers, static content, types.

Naming Conventions
- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.

TypeScript Usage
- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use maps instead.
- Use functional components with TypeScript interfaces.

Syntax and Formatting
- Use the "function" keyword for pure functions.
- Use curly braces for all conditionals. Favor simplicity over cleverness.
- Use declarative JSX.

UI and Styling
- Use Tailwind for components and styling.

Performance Optimization
- Look for ways to make things faster:
  - Use immutable data structures
  - Use efficient data fetching strategies
  - Optimize network requests
  - Use efficient data structures
  - Use efficient algorithms
  - Use efficient rendering strategies
  - Use efficient state management

---

# NEW: Development Infrastructure & Quality Standards

## Code Quality & Testing
- **Pre-commit Hooks**: Always run pre-commit hooks before committing (Black, isort, flake8 for Python; ESLint for TypeScript)
- **Test Coverage**: Maintain minimum 80% backend coverage, 70% frontend coverage
- **Testing Strategy**: Write comprehensive unit tests for all business logic
- **Code Formatting**: Use Black (Python) and Prettier (TypeScript) for consistent formatting
- **Linting**: Run flake8 (Python) and ESLint (TypeScript) to catch issues early

## Security Best Practices
- **JWT Security**: Use secure token lifetimes (15min access, 7 days refresh)
- **Token Rotation**: Implement refresh token rotation with blacklisting
- **Input Validation**: Always validate and sanitize user inputs
- **CORS Configuration**: Restrict CORS to trusted origins only
- **Security Scanning**: Integrate Trivy for container vulnerability scanning
- **Secret Management**: Never hardcode secrets; use environment variables

## CI/CD Pipeline Standards
- **Quality Gates**: All tests must pass before deployment
- **Security Scanning**: Run vulnerability scans on every build
- **Coverage Requirements**: Enforce minimum coverage thresholds
- **Staging First**: Always deploy to staging before production
- **Automated Testing**: Run full test suite on every push
- **Docker Security**: Scan all container images for vulnerabilities

## Development Workflow
- **Git Flow**: Use feature branches, conventional commits, and PR reviews
- **Code Review**: Require code review for all changes
- **Documentation**: Keep README files and API docs updated
- **Environment Management**: Use .env files and python-decouple for configuration
- **Dependency Management**: Keep dependencies updated and secure

## Performance & Monitoring
- **Database Optimization**: Use select_related/prefetch_related, add proper indexes
- **Caching Strategy**: Implement Redis caching for expensive operations
- **Async Operations**: Use Celery for background tasks
- **Health Checks**: Implement health check endpoints for monitoring
- **Logging**: Use structured logging for better debugging

## Team Collaboration
- **Standards Documentation**: Maintain comprehensive development standards
- **IDE Configuration**: Provide VS Code workspace with recommended extensions
- **Quick Reference**: Keep command reference guides updated
- **Onboarding**: Document setup process for new team members
- **Code Examples**: Include practical examples in documentation

## Docker & Deployment
- **Multi-stage Builds**: Use multi-stage Docker builds for production
- **Health Checks**: Implement proper health checks in containers
- **Environment Variables**: Use environment-specific .env files
- **Security Scanning**: Scan all images with Trivy before deployment
- **Rollback Strategy**: Have rollback procedures ready for production

## Error Handling & Logging
- **Structured Logging**: Use consistent log format across the application
- **Error Tracking**: Implement proper error monitoring and alerting
- **Graceful Degradation**: Handle failures gracefully with fallbacks
- **User Feedback**: Provide clear error messages to users
- **Debug Information**: Include relevant context in error logs

## API Design
- **RESTful Design**: Follow REST principles for API endpoints
- **Versioning**: Plan for API versioning from the start
- **Documentation**: Use DRF's built-in API documentation
- **Rate Limiting**: Implement API rate limiting for security
- **Response Format**: Use consistent response format across all endpoints

## Database Design
- **Migrations**: Always use Django migrations for schema changes
- **Indexing**: Add indexes for frequently queried fields
- **Relationships**: Use appropriate field types for relationships
- **Constraints**: Add database constraints for data integrity
- **Backup Strategy**: Plan for database backups and recovery

## Monitoring & Observability
- **Application Metrics**: Track response times, error rates, and throughput
- **Infrastructure Monitoring**: Monitor server resources and container health
- **Alerting**: Set up alerts for critical issues
- **Dashboards**: Create monitoring dashboards for key metrics
- **Log Aggregation**: Centralize logs for better debugging

Remember: These standards are living documents. Always prioritize security, performance, and maintainability in every decision. Follow the principle of "Convention Over Configuration" and leverage the full power of Django and React ecosystems.
